datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
}

// Instant Win Enums
enum InstantPrizeType {
  CASH
  RYDER_CASH
}

enum InstantResult {
  NONE
  WIN
}

model User {
  id                    String                @id @default(cuid())
  name                  String?
  email                 String                @unique
  password              String?
  image                 String?
  role                  String                @default("user") // "user" or "admin"
  ryderCash             Float                 @default(0.0) // RyderCash balance (site credit, non-withdrawable)
  cashBalance           Float                 @default(0.0) // Withdrawable cash balance from instant wins
  
  // Address Information
  addressLine1          String?
  addressLine2          String?
  city                  String?
  county                String?
  postcode              String?
  country               String?               @default("United Kingdom")
  
  // Contact Information
  phone                 String?
  dateOfBirth           DateTime?
  
  // Preferences
  emailNotifications    Boolean               @default(true)
  smsNotifications      Boolean               @default(false)
  marketingEmails       Boolean               @default(true)
  
  entries               Entry[]
  ryderCashTransactions RyderCashTransaction[]
  withdrawalRequests    WithdrawalRequest[]
  instantWinTickets     InstantWinTicket[]    // Tickets this user has won/claimed
  accounts              Account[]
  sessions              Session[]
  createdAt             DateTime              @default(now())
  updatedAt             DateTime              @updatedAt
  winner                Competition[]         @relation("WinnerRelation")
}

model Competition {
  id                String   @id @default(cuid())
  slug              String?  @unique
  title             String
  description       String
  image             String?
  startDate         DateTime
  endDate           DateTime
  ticketPrice       Float
  maxTickets        Int      @default(10000)
  prizeValue        Float?   // Optional direct prize value setting
  isActive          Boolean  @default(true)
  hasInstantWins    Boolean  @default(false) // Whether this competition has instant win prizes
  winnerId          String?
  winner            User?    @relation("WinnerRelation", fields: [winnerId], references: [id])
  winningTicketNumber Int?   // The winning ticket number
  drawId            String?  // Unique draw identifier for transparency
  drawTimestamp     DateTime? // When the draw was conducted
  entries             Entry[]
  instantPrizes       InstantPrize[]
  instantWinTickets   InstantWinTicket[]  // Pre-generated instant win ticket pool
  createdAt           DateTime @default(now())
  updatedAt           DateTime @updatedAt
}

model Entry {
  id            String        @id @default(cuid())
  user          User          @relation(fields: [userId], references: [id])
  userId        String
  competition   Competition   @relation(fields: [competitionId], references: [id])
  competitionId String
  ticketNumbers String        // JSON string of ticket numbers purchased
  quantity      Int           @default(1)
  totalCost     Float
  paymentMethod String        @default("card") // "card", "ryderCash", "mixed"
  ryderCashUsed Float         @default(0.0) // Amount of RyderCash used for this entry
  paymentStatus String        @default("pending") // "pending", "completed", "failed"
  
  // Instant Win fields - JSON array of results for each ticket in this entry
  // Format: [{ ticketNumber: 1, result: "NONE"|"WIN", prizeId?: string, prizeName?: string, prizeType?: string, value?: number }]
  instantWinResults String?   // JSON string of instant win results per ticket
  hasInstantWin     Boolean   @default(false) // Quick flag to check if any ticket won
  
  createdAt     DateTime      @default(now())
}

model RyderCashTransaction {
  id          String   @id @default(cuid())
  user        User     @relation(fields: [userId], references: [id])
  userId      String
  type        String   // "credit", "debit", "refund", "bonus", "admin_adjustment", "instant_win"
  amount      Float    // Positive for credits, negative for debits
  balance     Float    // User's balance after this transaction
  description String   // Description of the transaction
  reference   String?  // Optional reference (e.g., entry ID, competition ID)
  createdBy   String?  // Admin user ID if manually created
  createdAt   DateTime @default(now())
}

model InstantPrize {
  id            String           @id @default(cuid())
  competition   Competition      @relation(fields: [competitionId], references: [id], onDelete: Cascade)
  competitionId String
  
  name          String           // e.g., "£50 Cash Prize", "£10 Ryder Cash"
  prizeType     InstantPrizeType // CASH or RYDER_CASH
  value         Float            // Prize value in pounds (e.g., 50.00 = £50)
  totalWins     Int              // Total number of this prize available
  remainingWins Int              // How many are left to win
  
  // Relation to pre-assigned winning tickets
  instantWinTickets InstantWinTicket[]
  
  createdAt     DateTime         @default(now())
  updatedAt     DateTime         @updatedAt
  
  @@index([competitionId])
}

// Pre-generated instant win tickets with random numbers
// Each ticket is either a winning ticket (has prizeId) or just available for display
model InstantWinTicket {
  id              String         @id @default(cuid())
  competition     Competition    @relation(fields: [competitionId], references: [id], onDelete: Cascade)
  competitionId   String
  ticketNumber    Int            // Random number like 5532, 72672
  
  // Prize assignment (null = not a winning ticket, but displayed as "available")
  prize           InstantPrize?  @relation(fields: [prizeId], references: [id])
  prizeId         String?
  
  // Winner info (null = not yet claimed/purchased)
  winner          User?          @relation(fields: [winnerId], references: [id])
  winnerId        String?
  winnerName      String?        // Cached for display without joins
  
  createdAt       DateTime       @default(now())
  claimedAt       DateTime?      // When the ticket was purchased/claimed
  
  @@unique([competitionId, ticketNumber])
  @@index([competitionId])
  @@index([competitionId, prizeId])
}

model PasswordResetToken {
  id        String   @id @default(cuid())
  email     String
  token     String   @unique
  expiresAt DateTime
  createdAt DateTime @default(now())

  @@index([email])
  @@index([token])
}

// Withdrawal Request tracking
enum WithdrawalStatus {
  PENDING
  APPROVED
  REJECTED
  COMPLETED
}

model WithdrawalRequest {
  id          String           @id @default(cuid())
  user        User             @relation(fields: [userId], references: [id])
  userId      String
  amount      Float            // Amount requested to withdraw
  status      WithdrawalStatus @default(PENDING)
  
  // Payment details
  paymentMethod String         // "bank_transfer", "paypal", etc.
  paymentDetails String        // JSON string with payment details (account number, sort code, paypal email, etc.)
  
  // Processing
  processedBy String?          // Admin user ID who processed
  processedAt DateTime?        // When it was processed
  rejectionReason String?      // If rejected, why
  
  // Audit
  notes       String?          // Admin notes
  createdAt   DateTime         @default(now())
  updatedAt   DateTime         @updatedAt
  
  @@index([userId])
  @@index([status])
}

// NextAuth.js Models
model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}